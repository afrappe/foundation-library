// kotlin
package foundation.rosenblueth.library.network.classification

import android.util.Log
import com.google.gson.JsonObject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET
import retrofit2.http.Query
import retrofit2.http.Path

/**
 * Servicio especializado para obtener clasificaciones bibliográficas de múltiples fuentes
 */

// Library of Congress API
interface LOCClassificationApi {
    // https://www.loc.gov/books/?q=title:hamlet+author:shakespeare&fo=json
    @GET("books/")
    suspend fun searchBooks(
        @Query("q") query: String,
        @Query("fo") format: String = "json",
        @Query("c") count: Int = 10
    ): Response<JsonObject>

    // https://id.loc.gov/vocabulary/classSchemes/lcc.json
    @GET("vocabulary/classSchemes/lcc.json")
    suspend fun getLCCScheme(): Response<JsonObject>
}

// OCLC WorldCat API (más completa que xISBN)
interface WorldCatClassificationApi {
    // Nueva URL: https://worldcat.org/webservices/catalog/content/libraries
    // Alternativa funcional: http://www.worldcat.org/webservices/catalog/content/isbn/{isbn}?method=getMetadata&format=xml
    @GET("webservices/catalog/content/isbn/{isbn}")
    suspend fun classifyByISBN(
        @Path("isbn") isbn: String,
        @Query("method") method: String = "getMetadata",
        @Query("format") format: String = "xml"
    ): Response<String> // XML response

    // Búsqueda por título y autor (URL alternativa)
    @GET("webservices/catalog/search")
    suspend fun classifyByTitleAuthor(
        @Query("q") query: String,
        @Query("format") format: String = "xml",
        @Query("recordSchema") recordSchema: String = "info:srw/schema/1/marcxml-v1.1"
    ): Response<String>
}

// WorldCat xISBN (fallback más confiable)
interface WorldCatXISBNApi {
    // http://xisbn.worldcat.org/webservices/xid/isbn/9780140328721?method=getMetadata&format=json
    @GET("webservices/xid/isbn/{isbn}")
    suspend fun getMetadata(
        @Path("isbn") isbn: String,
        @Query("method") method: String = "getMetadata",
        @Query("format") format: String = "json"
    ): Response<JsonObject>
}

// Harvard Library API (para DDC)
interface HarvardLibraryApi {
    // https://api.lib.harvard.edu/v2/items?q=title:hamlet%20author:shakespeare
    @GET("v2/items")
    suspend fun searchItems(
        @Query("q") query: String,
        @Query("limit") limit: Int = 10
    ): Response<JsonObject>
}

// British Library API
interface BritishLibraryApi {
    // https://api.bl.uk/metadata/bibnumber/015890393?format=json
    @GET("metadata/bibnumber/{id}")
    suspend fun getByBibNumber(
        @Path("id") bibNumber: String,
        @Query("format") format: String = "json"
    ): Response<JsonObject>
}

// Deutsche Nationalbibliothek (para UDC/DCU)
interface DNBApi {
    // https://services.dnb.de/sru/authorities?version=1.1&operation=searchRetrieve&query=aut.person=Shakespeare
    @GET("sru/authorities")
    suspend fun searchAuthorities(
        @Query("version") version: String = "1.1",
        @Query("operation") operation: String = "searchRetrieve",
        @Query("query") query: String,
        @Query("recordSchema") recordSchema: String = "MARC21-xml"
    ): Response<String> // XML response
}

// Biblioteca Nacional de España (para CDU en español)
interface BNEApi {
    // http://catalogo.bne.es/uhtbin/webcat?searchtype=title&searcharg=hamlet
    @GET("uhtbin/webcat")
    suspend fun searchCatalog(
        @Query("searchtype") searchType: String = "title",
        @Query("searcharg") searchArg: String,
        @Query("format") format: String = "json"
    ): Response<JsonObject>
}

object ClassificationSearchService {
    private val TAG = "ClassificationSearch"

    // Configuración de clientes Retrofit con timeouts mejorados
    private val locRetrofit = Retrofit.Builder()
        .baseUrl("https://www.loc.gov/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val worldCatRetrofit = Retrofit.Builder()
        .baseUrl("http://www.worldcat.org/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val worldCatXISBNRetrofit = Retrofit.Builder()
        .baseUrl("http://xisbn.worldcat.org/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val harvardRetrofit = Retrofit.Builder()
        .baseUrl("https://api.lib.harvard.edu/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val britishLibRetrofit = Retrofit.Builder()
        .baseUrl("https://api.bl.uk/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val dnbRetrofit = Retrofit.Builder()
        .baseUrl("https://services.dnb.de/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val bneRetrofit = Retrofit.Builder()
        .baseUrl("http://catalogo.bne.es/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    // APIs
    private val locApi = locRetrofit.create(LOCClassificationApi::class.java)
    private val worldCatApi = worldCatRetrofit.create(WorldCatClassificationApi::class.java)
    private val worldCatXISBNApi = worldCatXISBNRetrofit.create(WorldCatXISBNApi::class.java)
    private val harvardApi = harvardRetrofit.create(HarvardLibraryApi::class.java)
    private val britishLibApi = britishLibRetrofit.create(BritishLibraryApi::class.java)
    private val dnbApi = dnbRetrofit.create(DNBApi::class.java)
    private val bneApi = bneRetrofit.create(BNEApi::class.java)

    /**
     * Busca clasificaciones usando datos del libro (estrategia de búsqueda híbrida)
     * TEMPORALMENTE SIMPLIFICADO - Retorna null para evitar errores de conectividad
     */
    suspend fun searchClassificationsByBookData(
        isbn: String? = null,
        title: String? = null,
        author: String? = null,
        publisher: String? = null
    ): EnhancedClassifications? = withContext(Dispatchers.IO) {

        Log.d(TAG, "=== Búsqueda de clasificaciones iniciada (MODO SIMPLIFICADO) ===")
        Log.d(TAG, "ISBN: '$isbn', Título: '$title', Autor: '$author', Editorial: '$publisher'")

        // TEMPORALMENTE DESHABILITADO para resolver problemas de conectividad
        // Retorna null para que use solo las fuentes básicas que ya funcionan
        Log.d(TAG, "Servicios avanzados temporalmente deshabilitados")
        Log.d(TAG, "=== Resultado: Sin clasificaciones adicionales ===")

        return@withContext null
    }

    private suspend fun tryWorldCatByISBN(isbn: String): EnhancedClassifications? {
        return try {
            Log.d(TAG, "Intentando WorldCat por ISBN: $isbn")
            val response = worldCatApi.classifyByISBN(isbn)
            if (response.isSuccessful && response.body() != null) {
                val xmlBody = response.body()!!
                Log.d(TAG, "WorldCat XML response: ${xmlBody.take(500)}...")
                parseWorldCatXMLResponse(xmlBody)
            } else {
                Log.d(TAG, "WorldCat por ISBN falló: ${response.code()} - ${response.message()}")
                null
            }
        } catch (e: java.net.SocketException) {
            Log.e(TAG, "Error de conexión en WorldCat por ISBN: ${e.message}")
            Log.d(TAG, "Saltando WorldCat - servicio no disponible")
            null
        } catch (e: Exception) {
            Log.e(TAG, "Error en WorldCat por ISBN: ${e.javaClass.simpleName} - ${e.message}")
            null
        }
    }

    private suspend fun tryWorldCatByTitleAuthor(title: String, author: String?): EnhancedClassifications? {
        return try {
            Log.d(TAG, "Intentando WorldCat por título: '$title', autor: '$author'")
            val query = if (author != null) "title:$title author:$author" else "title:$title"
            val response = worldCatApi.classifyByTitleAuthor(query)
            if (response.isSuccessful && response.body() != null) {
                val xmlBody = response.body()!!
                Log.d(TAG, "WorldCat XML response: ${xmlBody.take(500)}...")
                parseWorldCatXMLResponse(xmlBody)
            } else {
                Log.d(TAG, "WorldCat por título/autor falló: ${response.code()} - ${response.message()}")
                null
            }
        } catch (e: java.net.SocketException) {
            Log.e(TAG, "Error de conexión en WorldCat por título/autor: ${e.message}")
            Log.d(TAG, "Saltando WorldCat - servicio no disponible")
            null
        } catch (e: Exception) {
            Log.e(TAG, "Error en WorldCat por título/autor: ${e.javaClass.simpleName} - ${e.message}")
            null
        }
    }

    private suspend fun tryLOCByTitleAuthor(title: String, author: String?): EnhancedClassifications? {
        return try {
            val query = buildLOCQuery(title, author)
            Log.d(TAG, "Intentando LOC con query: '$query'")
            val response = locApi.searchBooks(query)
            if (response.isSuccessful && response.body() != null) {
                parseLOCResponse(response.body()!!)
            } else {
                Log.d(TAG, "LOC falló: ${response.code()}")
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en LOC", e)
            null
        }
    }

    private suspend fun tryHarvardByTitleAuthor(title: String, author: String?): EnhancedClassifications? {
        return try {
            val query = buildHarvardQuery(title, author)
            Log.d(TAG, "Intentando Harvard con query: '$query'")
            val response = harvardApi.searchItems(query)
            if (response.isSuccessful && response.body() != null) {
                parseHarvardResponse(response.body()!!)
            } else {
                Log.d(TAG, "Harvard falló: ${response.code()}")
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en Harvard", e)
            null
        }
    }

    private suspend fun tryBritishLibraryByTitle(title: String, author: String?): EnhancedClassifications? {
        return try {
            // British Library requiere búsqueda por número bibliográfico
            // Por ahora retornamos null - requiere implementación más compleja
            Log.d(TAG, "British Library: implementación pendiente")
            null
        } catch (e: Exception) {
            Log.e(TAG, "Error en British Library", e)
            null
        }
    }

    private suspend fun tryBNEByTitle(title: String): EnhancedClassifications? {
        return try {
            Log.d(TAG, "Intentando BNE con título: '$title'")
            val response = bneApi.searchCatalog(searchArg = title)
            if (response.isSuccessful && response.body() != null) {
                parseBNEResponse(response.body()!!)
            } else {
                Log.d(TAG, "BNE falló: ${response.code()}")
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en BNE", e)
            null
        }
    }

    private suspend fun tryDNBByAuthor(author: String): EnhancedClassifications? {
        return try {
            val query = "aut.person=${author}"
            Log.d(TAG, "Intentando DNB con query: '$query'")
            val response = dnbApi.searchAuthorities(query = query)
            if (response.isSuccessful && response.body() != null) {
                parseDNBXMLResponse(response.body()!!)
            } else {
                Log.d(TAG, "DNB falló: ${response.code()}")
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en DNB", e)
            null
        }
    }

    // Funciones de parsing
    private fun parseWorldCatXMLResponse(xmlResponse: String): EnhancedClassifications? {
        return try {
            val classifications = EnhancedClassifications()
            Log.d(TAG, "Parsing WorldCat XML, primera línea: ${xmlResponse.lines().firstOrNull()}")

            // Múltiples patrones para diferentes formatos de respuesta de WorldCat

            // Patrón 1: <lcc>...</lcc> (formato clasificación directa)
            val lcPattern1 = Regex("<lcc>(.*?)</lcc>", RegexOption.IGNORE_CASE)
            lcPattern1.findAll(xmlResponse).forEach { match ->
                val classification = match.groupValues[1].trim()
                if (classification.isNotEmpty()) {
                    classifications.lcClassification.add(classification)
                    Log.d(TAG, "LC encontrado (patrón 1): $classification")
                }
            }

            // Patrón 2: <ddc>...</ddc> (formato clasificación directa)
            val ddcPattern1 = Regex("<ddc>(.*?)</ddc>", RegexOption.IGNORE_CASE)
            ddcPattern1.findAll(xmlResponse).forEach { match ->
                val classification = match.groupValues[1].trim()
                if (classification.isNotEmpty()) {
                    classifications.deweyClassification.add(classification)
                    Log.d(TAG, "Dewey encontrado (patrón 1): $classification")
                }
            }

            // Patrón 3: Buscar en elementos de clasificación MARC
            val marcClassPattern = Regex("<datafield tag=\"050\"[^>]*>.*?<subfield code=\"a\">(.*?)</subfield>", RegexOption.IGNORE_CASE or RegexOption.DOT_MATCHES_ALL)
            marcClassPattern.findAll(xmlResponse).forEach { match ->
                val classification = match.groupValues[1].trim()
                if (classification.isNotEmpty()) {
                    classifications.lcClassification.add(classification)
                    Log.d(TAG, "LC encontrado (MARC 050): $classification")
                }
            }

            // Patrón 4: DDC en formato MARC
            val marcDDCPattern = Regex("<datafield tag=\"082\"[^>]*>.*?<subfield code=\"a\">(.*?)</subfield>", RegexOption.IGNORE_CASE or RegexOption.DOT_MATCHES_ALL)
            marcDDCPattern.findAll(xmlResponse).forEach { match ->
                val classification = match.groupValues[1].trim()
                if (classification.isNotEmpty()) {
                    classifications.deweyClassification.add(classification)
                    Log.d(TAG, "Dewey encontrado (MARC 082): $classification")
                }
            }

            // Patrón 5: Subject headings
            val subjectPattern = Regex("<datafield tag=\"650\"[^>]*>.*?<subfield code=\"a\">(.*?)</subfield>", RegexOption.IGNORE_CASE or RegexOption.DOT_MATCHES_ALL)
            subjectPattern.findAll(xmlResponse).forEach { match ->
                val subject = match.groupValues[1].trim()
                if (subject.isNotEmpty()) {
                    classifications.subjectHeadings.add(subject)
                    Log.d(TAG, "Subject encontrado: $subject")
                }
            }

            classifications.sources.add("WorldCat")

            Log.d(TAG, "WorldCat parsing result: LC=${classifications.lcClassification.size}, DDC=${classifications.deweyClassification.size}, Subjects=${classifications.subjectHeadings.size}")

            if (classifications.hasAnyClassification()) classifications else null
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing WorldCat XML: ${e.message}", e)
            null
        }
    }

    private fun parseLOCResponse(jsonResponse: JsonObject): EnhancedClassifications? {
        return try {
            val classifications = EnhancedClassifications()

            val results = jsonResponse.getAsJsonArray("results")
            results?.forEach { result ->
                val item = result.asJsonObject

                // LC Classification
                val lcClass = item.getAsJsonPrimitive("class")?.asString
                lcClass?.let { classifications.lcClassification.add(it) }

                // Subject headings
                val subjects = item.getAsJsonArray("subject")
                subjects?.forEach { subject ->
                    classifications.subjectHeadings.add(subject.asString)
                }
            }

            classifications.sources.add("Library of Congress")
            if (classifications.hasAnyClassification()) classifications else null
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing LOC response", e)
            null
        }
    }

    private fun parseHarvardResponse(jsonResponse: JsonObject): EnhancedClassifications? {
        return try {
            val classifications = EnhancedClassifications()

            val docs = jsonResponse.getAsJsonObject("docs")
            docs?.let { docsObj ->
                val items = docsObj.getAsJsonArray("items")
                items?.forEach { item ->
                    val itemObj = item.asJsonObject

                    // Buscar clasificaciones en metadatos
                    val classification = itemObj.getAsJsonPrimitive("classification")?.asString
                    classification?.let {
                        if (it.matches(Regex("^[0-9]{3}.*"))) {
                            classifications.deweyClassification.add(it)
                        } else {
                            classifications.otherClassifications["Harvard"] = it
                        }
                    }
                }
            }

            classifications.sources.add("Harvard Library")
            if (classifications.hasAnyClassification()) classifications else null
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing Harvard response", e)
            null
        }
    }

    private fun parseBNEResponse(jsonResponse: JsonObject): EnhancedClassifications? {
        return try {
            val classifications = EnhancedClassifications()

            // Implementación básica - BNE puede usar CDU
            val records = jsonResponse.getAsJsonArray("records")
            records?.forEach { record ->
                val recordObj = record.asJsonObject
                val cdu = recordObj.getAsJsonPrimitive("cdu")?.asString
                cdu?.let { classifications.udcClassification.add(it) }
            }

            classifications.sources.add("Biblioteca Nacional de España")
            if (classifications.hasAnyClassification()) classifications else null
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing BNE response", e)
            null
        }
    }

    private fun parseDNBXMLResponse(xmlResponse: String): EnhancedClassifications? {
        return try {
            val classifications = EnhancedClassifications()

            // Buscar UDC/DCU en respuesta XML
            val udcPattern = Regex("<dc:subject[^>]*>([0-9]+.*?)</dc:subject>")
            udcPattern.findAll(xmlResponse).forEach { match ->
                val udc = match.groupValues[1]
                if (udc.matches(Regex("^[0-9].*"))) {
                    classifications.udcClassification.add(udc)
                }
            }

            classifications.sources.add("Deutsche Nationalbibliothek")
            if (classifications.hasAnyClassification()) classifications else null
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing DNB XML", e)
            null
        }
    }

    // Funciones auxiliares
    private fun buildLOCQuery(title: String, author: String?): String {
        return if (!author.isNullOrBlank()) {
            "title:$title author:$author"
        } else {
            "title:$title"
        }
    }

    private fun buildHarvardQuery(title: String, author: String?): String {
        return if (!author.isNullOrBlank()) {
            "title:$title author:$author"
        } else {
            "title:$title"
        }
    }

    private fun isEnglishTitle(title: String): Boolean {
        // Simple heurística para detectar títulos en inglés
        val englishWords = setOf("the", "and", "of", "in", "to", "a", "an", "for", "with", "on", "at", "by", "from")
        val words = title.lowercase().split(" ")
        return words.any { it in englishWords }
    }

    private fun isSpanishTitle(title: String): Boolean {
        // Simple heurística para detectar títulos en español
        val spanishWords = setOf("el", "la", "los", "las", "de", "del", "en", "y", "un", "una", "para", "con", "por")
        val words = title.lowercase().split(" ")
        return words.any { it in spanishWords }
    }

    private suspend fun tryWorldCatXISBN(isbn: String): EnhancedClassifications? {
        return try {
            Log.d(TAG, "Intentando WorldCat xISBN: $isbn")
            val response = worldCatXISBNApi.getMetadata(isbn)
            if (response.isSuccessful && response.body() != null) {
                val metadata = response.body()!!
                Log.d(TAG, "WorldCat xISBN response: $metadata")
                parseWorldCatXISBNResponse(metadata)
            } else {
                Log.d(TAG, "WorldCat xISBN falló: ${response.code()} - ${response.message()}")
                null
            }
        } catch (e: java.net.SocketException) {
            Log.e(TAG, "Error de conexión en WorldCat xISBN: ${e.message}")
            null
        } catch (e: Exception) {
            Log.e(TAG, "Error en WorldCat xISBN: ${e.javaClass.simpleName} - ${e.message}")
            null
        }
    }

    private fun parseWorldCatXISBNResponse(metadata: JsonObject): EnhancedClassifications? {
        return try {
            val classifications = EnhancedClassifications()

            // El servicio xISBN devuelve metadatos básicos, no clasificaciones directas
            // Pero podemos extraer información útil como títulos y autores para búsquedas posteriores
            val title = metadata.getAsJsonPrimitive("title")?.asString
            val author = metadata.getAsJsonPrimitive("author")?.asString

            if (title != null) {
                Log.d(TAG, "WorldCat xISBN - Título: $title, Autor: $author")
                // Este servicio confirma la existencia del libro pero no da clasificaciones directas
                classifications.sources.add("WorldCat xISBN")

                // Podríamos usar esta información para búsquedas adicionales en otras fuentes
                if (author != null) {
                    classifications.otherClassifications["xisbn_title"] = title
                    classifications.otherClassifications["xisbn_author"] = author
                }
            }

            null // xISBN no proporciona clasificaciones directamente
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing WorldCat xISBN response: ${e.message}")
            null
        }
    }
}

/**
 * Modelo de datos enriquecido para clasificaciones múltiples
 */
data class EnhancedClassifications(
    val lcClassification: MutableList<String> = mutableListOf(),
    val deweyClassification: MutableList<String> = mutableListOf(),
    val udcClassification: MutableList<String> = mutableListOf(), // UDC/CDU
    val subjectHeadings: MutableList<String> = mutableListOf(),
    val otherClassifications: MutableMap<String, String> = mutableMapOf(),
    val sources: MutableList<String> = mutableListOf()
) {
    fun hasAnyClassification(): Boolean {
        return lcClassification.isNotEmpty() ||
               deweyClassification.isNotEmpty() ||
               udcClassification.isNotEmpty() ||
               otherClassifications.isNotEmpty()
    }

    fun merge(other: EnhancedClassifications) {
        lcClassification.addAll(other.lcClassification)
        deweyClassification.addAll(other.deweyClassification)
        udcClassification.addAll(other.udcClassification)
        subjectHeadings.addAll(other.subjectHeadings)
        otherClassifications.putAll(other.otherClassifications)
        sources.addAll(other.sources)

        // Remover duplicados
        val uniqueLC = lcClassification.distinct()
        lcClassification.clear()
        lcClassification.addAll(uniqueLC)

        val uniqueDewey = deweyClassification.distinct()
        deweyClassification.clear()
        deweyClassification.addAll(uniqueDewey)

        val uniqueUDC = udcClassification.distinct()
        udcClassification.clear()
        udcClassification.addAll(uniqueUDC)

        val uniqueSubjects = subjectHeadings.distinct()
        subjectHeadings.clear()
        subjectHeadings.addAll(uniqueSubjects)
    }

    fun getBestLC(): String? = lcClassification.firstOrNull()
    fun getBestDewey(): String? = deweyClassification.firstOrNull()
    fun getBestUDC(): String? = udcClassification.firstOrNull()
}
